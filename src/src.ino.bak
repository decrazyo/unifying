
#include <RF24.h>
#include <printf.h>

#include "aes.hpp"

#include "unifying_protocol.h"
#include "unifying_user.h"

#define CE_PIN 7
#define CSN_PIN 8
#define KEY_PIN 2
#define DEFAULT_TIMEOUT 110


RF24 radio(CE_PIN, CSN_PIN);

const uint8_t press[UNIFYING_KEYS_LEN] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x04};
const uint8_t release[UNIFYING_KEYS_LEN] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
uint8_t aes_key[UNIFYING_AES_BLOCK_LEN];
uint32_t aes_counter;
uint8_t global_buffer[32];
uint32_t last_keep_alive;
uint16_t unifying_timeout;
uint16_t unifying_interval;
bool key_pressed;
bool key_released;
bool key_queued;
bool key_state;
bool update_timeout;

uint8_t unifying_transmit_payload(const uint8_t* payload, uint8_t payload_length) {
  Serial.print("Transmit: ");
  unifying_print_buffer(payload, payload_length);
  bool status = radio.write(payload, payload_length);
  return (uint8_t) !status;
}

uint8_t unifying_receive_ack_payload(uint8_t* payload, uint8_t payload_length) {
  if(!radio.available()) {
    return 0;
  }

  uint8_t length = radio.getDynamicPayloadSize();
  radio.read(payload, payload_length);

  Serial.print("Receive:  ");
  unifying_print_buffer(payload, payload_length);

  return length;
}

uint8_t unifying_set_address(const uint8_t address[UNIFYING_ADDRESS_LEN]) {
  uint8_t temp[UNIFYING_ADDRESS_LEN];
  unifying_copy_reverse(temp, address, UNIFYING_ADDRESS_LEN);
  Serial.print("Address:  ");
  unifying_print_buffer(address, UNIFYING_ADDRESS_LEN);
  radio.openWritingPipe(temp);
  return 0;
}

uint8_t unifying_set_channel(uint8_t channel) {
  Serial.print("Channel:  ");
  Serial.println(channel);
  radio.setChannel(channel);
  return 0;
}

uint8_t unifying_get_channel() {
  return radio.getChannel();
}

uint32_t unifying_random() {
  return random();
}

uint8_t unifying_encrypt(uint8_t buffer[UNIFYING_AES_DATA_LEN],
                         const uint8_t key[UNIFYING_AES_BLOCK_LEN],
                         const uint8_t iv[UNIFYING_AES_BLOCK_LEN]) {
  struct AES_ctx ctx;
  AES_init_ctx_iv(&ctx, key, iv);
  AES_CTR_xcrypt_buffer(&ctx, buffer, UNIFYING_AES_DATA_LEN);
  return 0;
}

uint8_t ascii_to_scancode(uint8_t ascii) {
  if(isupper(ascii)) {
    ascii -= 'A';
    return ascii + 0x04; // A - Z
  }
  else if(islower(ascii)) {
    ascii -= 'a';
    return ascii + 0x04; // a - z
  }
  else if(isdigit(ascii)) {
    ascii -= '0'; // Convert ascii digit to int.
    if(ascii) {
      return ascii + 0x1d; // 1 - 9
    }
    return 0x27; // 0
  }

  return 0x2C; // space
}


void set_timeout(uint16_t timeout) {
  unifying_timeout = timeout;
  // unifying_interval = timeout * 0.875;
  unifying_interval = timeout * 0.5;
}


void setup() {

  Serial.begin(115200);
  while(!Serial) {delay(100);}
  printf_begin();
  delay(1000);

  pinMode(KEY_PIN, INPUT_PULLUP);

  randomSeed(analogRead(0));

  Serial.println(F("Configured random"));

  if(!radio.begin()) {
    Serial.println(F("Radio not responding"));
    while(true) {delay(100);}
  }

  // Assert defaults to document the correct settings.
  radio.powerUp();
  radio.stopListening();
  radio.setPALevel(RF24_PA_MAX, true);
  radio.setCRCLength(RF24_CRC_16);
  radio.setAddressWidth(sizeof(unifying_pairing_address));
  radio.setAutoAck(true);

  // Assert non-default settings.
  radio.setDataRate(RF24_2MBPS);
  radio.enableDynamicPayloads();
  radio.enableAckPayload();
  radio.setRetries(15, 10);

  // Make sure we don't have any extraneous data in the RX FIFO.
  // The TX FIFO should have already been flushed by calling stopListening()
  radio.flush_rx();

  Serial.println(F("Configured radio"));

  uint8_t address[UNIFYING_ADDRESS_LEN];
  unifying_timeout = DEFAULT_TIMEOUT;
  uint16_t product_id = 0x1025;
  uint16_t device_type = 0x0147;
  uint32_t serial = 0xA58094B6;
  uint16_t capabilities = 0x1E40;
  char name[] = "Hacked";
  uint8_t name_length = strlen(name);

  enum unifying_error err = unifying_pair(aes_key,
                                          address,
                                          unifying_timeout,
                                          product_id,
                                          device_type,
                                          serial,
                                          capabilities,
                                          name,
                                          name_length);
  Serial.println(unifying_error_text[err]);

  if(err) {
    while(true) {delay(100);}
  }

  aes_counter = random();

  Serial.print("AES Counter: ");
  Serial.println(aes_counter, HEX);

  Serial.print("AES Key: ");
  unifying_print_buffer(aes_key, UNIFYING_AES_BLOCK_LEN);

  Serial.print("Address: ");
  unifying_print_buffer(address, UNIFYING_ADDRESS_LEN);

  while(true) {
    last_keep_alive = millis();
    err = unifying_set_timeout(unifying_timeout);
    Serial.println(unifying_error_text[err]);

    if(!err) {
      break;
    }

    delay(10);
  }

  set_timeout(unifying_timeout);

  key_pressed = false;
  key_released = false;
  key_queued = false;
  update_timeout = false;
  key_state = HIGH;
}





void loop() {
  enum unifying_error err = UNIFYING_SUCCESS;
  uint32_t current_time = millis();

  if(last_keep_alive + unifying_interval <= current_time) {
    last_keep_alive = current_time;

    if(radio.available()){
      err = unifying_hidpp_1_0();
    }
    else if(key_pressed) {
      key_pressed = false;
      err = unifying_encrypted_keystroke(press, 0x00, aes_key, aes_counter);
      // Implied switch to 20ms keep alive interval.
      set_timeout(20);
      aes_counter++;
    }
    else if(key_released) {
      key_released = false;
      err = unifying_encrypted_keystroke(release, 0x00, aes_key, aes_counter);
      // Still using a 20ms keep alive interval.
      aes_counter++;
      update_timeout = true;
    }
    else if(update_timeout) {
      update_timeout = false;
      set_timeout(DEFAULT_TIMEOUT);
      err = unifying_set_timeout(unifying_timeout);
    }
    else {
      err = unifying_keep_alive(unifying_timeout);
    }
    Serial.println(unifying_error_text[err]);
  }

  // Check for key presses.
  if(key_state == LOW && digitalRead(KEY_PIN) == HIGH) {
    // Key released.
    key_state = HIGH;
    key_released = true;
    Serial.println("RELEASE");
  }
  else if(key_state == HIGH && digitalRead(KEY_PIN) == LOW) {
    // Key pressed.
    key_state = LOW;
    key_pressed = true;
    Serial.println("PRESS");
  }

}
