
/*!
 * \file unifying_utils.h
 * \brief Miscellaneous utility functions used by the Unifying protocol
 */

#ifndef UNIFYING_UTILS_H
#define UNIFYING_UTILS_H

#include <stdint.h>
#include <stddef.h>
#include <stdio.h>
#include <string.h>

#include "unifying_const.h"

/*!
 * Plaintext keystroke data to be encrypted.
 */
struct unifying_encrypted_keystroke_plaintext
{
    /// Bitfield where each bit corresponds to a specific modifier key.
    uint8_t modifiers;
    /// Buffer of \ref UNIFYING_KEYS_LEN keyboard scancodes
    uint8_t keys[UNIFYING_KEYS_LEN];
    /// Constant value that a Unifying receiver uses to verify that decryption succeeded.
    uint8_t flag;
};

/*!
 * Counter-mode AES encryption initialization vector (IV) data.
 */
struct unifying_encrypted_keystroke_iv
{
    /*!
     * Constant AES nonce prefix.
     * \see unifying_aes_nonce_prefix
     */
    uint8_t prefix[UNIFYING_AES_NONCE_PREFIX_LEN];
    /// AES counter.
    uint32_t counter;
    /*!
     * Constant AES nonce suffix.
     * \see unifying_aes_nonce_suffix
     */
    uint8_t suffix[UNIFYING_AES_NONCE_SUFFIX_LEN];
};
/*!
 * Obfuscated AES encryption key data.
 */
struct unifying_proto_aes_key
{
    /*!
     * 4 most significant bytes of the RF address that the Unifying receiver sets for us during pairing.
     * This is also the serial number of the paired receiver.
     */
    uint8_t base_address[UNIFYING_ADDRESS_LEN - 1];
    /// The product ID of this device. This can be any value.
    uint16_t device_product_id;
    /// The product ID of the paired receiver. This appears to always be 0x8802.
    uint16_t receiver_product_id;
    /// 4 bytes of seemingly random data generated by this device.
    uint32_t device_crypto;
    /// 4 bytes of seemingly random data generated by the paired receiver.
    uint32_t receiver_crypto;
};

#ifdef __cplusplus
extern "C" {
#endif

/*!
 * Pack a 16-bit integer into a byte array.
 * 
 * Bytes are packed into the array with the most significant byte first.
 * 
 * \param[out]  packed  Pointer to byte array that is at least 2 bytes long.
 * \param[in]   number  A 16-bit integer to pack.
 */
void unifying_uint16_pack(uint8_t packed[2], uint16_t number);

/*!
 * Unpack a byte array into a 16-bit integer.
 * 
 * Array bytes are expected to have the most significant byte first.
 * 
 * \param[out]  number  Pointer to a 16-bit integer to unpack into.
 * \param[in]   packed  Pointer to byte array that is at least 2 bytes long.
 */
void unifying_uint16_unpack(uint16_t* number, const uint8_t packed[2]);

/*!
 * Pack a 32-bit integer into a byte array.
 * 
 * Bytes are packed into the array with the most significant byte first.
 * 
 * \param[out]  packed  Pointer to byte array that is at least 4 bytes long.
 * \param[in]   number  A 32-bit integer to pack.
 */
void unifying_uint32_pack(uint8_t packed[4], uint32_t number);

/*!
 * Unpack a byte array into a 32-bit integer.
 * 
 * Array bytes are expected to have the most significant byte first.
 * 
 * \param[out]  number  Pointer to a 32-bit integer to unpack into.
 * \param[in]   packed  Pointer to byte array that is at least 4 bytes long.
 */
void unifying_uint32_unpack(uint32_t* number, const uint8_t packed[4]);

/*!
 * Clamp a 16-bit integer to a 12-bit range.
 * 
 * \param[in]   number  A 16-bit integer to clamp.
 * 
 * \return A 16-bit integer with its value clamped to a 12-bit range.
 * 
 * \see unifying_mouse_move_request_pack()
 */
int16_t unifying_int12_clamp(int16_t number);

/*!
 * Compute the checksum of a byte array.
 * 
 * \param[in]   buffer  Pointer to a byte array to compute the checksum for.
 * \param[in]   length  Length of the byte array.
 * 
 * \return The checksum of \p length bytes in \p buffer.
 */
uint8_t unifying_checksum(const uint8_t* buffer, uint8_t length);

/*!
 * Verify the checksum of a byte array.
 * 
 * Compute the checksum of the first \p length `- 1` bytes of \p buffer and compare it to the last byte of \p buffer.
 * 
 * \param[in]   buffer  Pointer to a byte array to verify.
 * \param[in]   length  Length of the byte array.
 * 
 * \return `0` if the checksum is correct.
 * \return `1` if the checksum is incorrect.
 * 
 * \see unifying_checksum()
 */
uint8_t unifying_checksum_verify(const uint8_t* buffer, uint8_t length);

/*!
 * Perform a bitwise XNOR on 2 bytes and return the result.
 * 
 * \param[in]   first   A byte.
 * \param[in]   second  Another byte.
 * 
 * \return The bitwise XOR of \p first and \p second followed by a bitwise negation.
 * 
 * \see unifying_deobfuscate_aes_key()
 */
uint8_t unifying_xnor(uint8_t first, uint8_t second);

/*!
 * Initialize a \ref unifying_encrypted_keystroke_plaintext structure.
 * 
 * \param[out]  unpacked    Pointer to a \ref unifying_encrypted_keystroke_plaintext to initialize.
 * \param[in]   modifiers   Bitfield where each bit corresponds to a specific modifier key.
 * \param[in]   keys        Pointer to a buffer of \ref UNIFYING_KEYS_LEN keyboard scancodes.
 * 
 * \see unifying_encrypted_keystroke_plaintext
 */
void unifying_encrypted_keystroke_plaintext_init(struct unifying_encrypted_keystroke_plaintext* unpacked,
                                                 uint8_t modifiers,
                                                 const uint8_t keys[UNIFYING_KEYS_LEN]);

/*!
 * Pack a \ref unifying_encrypted_keystroke_plaintext into a byte array.
 * 
 * \param[out]  packed      Pointer to byte array that is at least \ref UNIFYING_AES_DATA_LEN bytes long.
 * \param[in]   unpacked    A \ref unifying_encrypted_keystroke_plaintext to pack.
 */
void unifying_encrypted_keystroke_plaintext_pack(uint8_t packed[UNIFYING_AES_DATA_LEN],
                                                 const struct unifying_encrypted_keystroke_plaintext* unpacked);

/*!
 * Initialize a \ref unifying_encrypted_keystroke_iv structure.
 * 
 * \param[out]  unpacked    Pointer to a \ref unifying_encrypted_keystroke_iv to initialize.
 * \param[in]   counter     AES counter.
 * 
 * \see unifying_encrypted_keystroke_iv
 */
void unifying_encrypted_keystroke_iv_init(struct unifying_encrypted_keystroke_iv* unpacked,
                                          uint32_t counter);

/*!
 * Pack a \ref unifying_encrypted_keystroke_iv into a byte array.
 * 
 * \param[out]  packed      Pointer to byte array that is at least \ref UNIFYING_AES_BLOCK_LEN bytes long.
 * \param[in]   unpacked    A \ref unifying_encrypted_keystroke_iv to pack.
 */
void unifying_encrypted_keystroke_iv_pack(uint8_t packed[UNIFYING_AES_BLOCK_LEN],
                                          const struct unifying_encrypted_keystroke_iv* unpacked);

/*!
 * Initialize a \ref unifying_proto_aes_key structure.
 * 
 * \param[out]  unpacked                Pointer to a \ref unifying_proto_aes_key to initialize.
 * \param[in]   base_address            Byte array containing the `4` most significant bytes the RF address.
 *                                      Most significant byte first.
 * \param[in]   device_product_id       The product ID of this device.
 * \param[in]   receiver_product_id     The product ID of the paired receiver.
 * \param[in]   device_crypto           4 bytes of random data generated by this device.
 * \param[in]   receiver_crypto         4 bytes of random data generated by the paired receiver.
 * 
 * \see unifying_proto_aes_key
 */
void unifying_proto_aes_key_init(struct unifying_proto_aes_key* unpacked,
                                     uint8_t base_address[UNIFYING_ADDRESS_LEN - 1],
                                     uint16_t device_product_id,
                                     uint16_t receiver_product_id,
                                     uint32_t device_crypto,
                                     uint32_t receiver_crypto);

/*!
 * Pack a \ref unifying_proto_aes_key into a byte array.
 * 
 * \param[out]  packed      Pointer to byte array that is at least \ref UNIFYING_AES_BLOCK_LEN bytes long.
 * \param[in]   unpacked    Pointer to a \ref unifying_proto_aes_key to pack.
 */
void unifying_proto_aes_key_pack(uint8_t packed[UNIFYING_AES_BLOCK_LEN],
                                 const struct unifying_proto_aes_key* unpacked);

/*!
 * De-obfuscate a Logitech Unifying AES key.
 * 
 * \param[out]  aes_key         Buffer of at least \ref UNIFYING_AES_BLOCK_LEN bytes to store the de-obfuscate AES key.
 * \param[in]   proto_aes_key   At least \ref UNIFYING_AES_BLOCK_LEN bytes of obfuscated AES key data.
 * 
 * \see unifying_proto_aes_key
 * \see unifying_proto_aes_key_init()
 * \see unifying_proto_aes_key_pack()
 * \see unifying_aes_key_bitmask
 * \see unifying_xnor()
 * \see unifying_aes_key_index
 */
void unifying_deobfuscate_aes_key(uint8_t aes_key[UNIFYING_AES_BLOCK_LEN],
                                  const uint8_t proto_aes_key[UNIFYING_AES_BLOCK_LEN]);

/*!
 * Compute the next RF channel to use if a transmission fails.
 * 
 * \param[in]   current_channel     The current RF channel.
 * 
 * \return  A new RF channel to use.
 * 
 * \see unifying_channels
 */
uint8_t unifying_next_channel(uint8_t current_channel);

/*!
 * Reverse the order of a byte array.
 * 
 * This function is provided purely for the convenience of this library's user.
 * This library stores RF addresses with the most significant byte first
 * but nRF24 radios expect addresses to be specified with the least significant byte first.
 * Since this library's user is expected to write functions for interfacing with nRF hardware,
 * they may need a way to reverse the byte order of an RF addresses.
 * 
 * \param[out]  reverse     A buffer that is at least \p length bytes long to contain the reverse of \p forward.
 * \param[in]   forward     A buffer of at least \p length bytes to reverse.
 * \param[in]   length      Size of \p reverse and \p forward.
 */
void unifying_copy_reverse(uint8_t *reverse, const uint8_t *forward, uint8_t length);

/*!
 * Print a buffer to stdout.
 * 
 * This function is provided for debugging purposes.
 * 
 * \param[in]   buffer  A buffer of at least \p length bytes to print.
 * \param[in]   length  Size of \p buffer.
 */
void unifying_print_buffer(const uint8_t *buffer, uint8_t length);

#ifdef __cplusplus
}
#endif

#endif
